OUTPUT_FORMAT("elf32-littlemips", "elf32-bigmips",
	      "elf32-littlemips")
OUTPUT_ARCH(mips)
ENTRY(_start)
 SEARCH_DIR(/usr/local/sce/iop/gcc//mipsel-scei-elfl/lib);
/* Do we need any of these for elf?
   __DYNAMIC = 0;    */
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0x0400000;
  .interp     : { *(.interp) 	}
  .reginfo : { *(.reginfo) }
  .hash          : { *(.hash)		}
  .dynsym        : { *(.dynsym)		}
  .dynstr        : { *(.dynstr)		}
  .gnu.version   : { *(.gnu.version)	}
  .gnu.version_d   : { *(.gnu.version_d)	}
  .gnu.version_r   : { *(.gnu.version_r)	}
  .rel.text      :
    { *(.rel.text) *(.rel.gnu.linkonce.t*) }
  .rela.text     :
    { *(.rela.text) *(.rela.gnu.linkonce.t*) }
  .rel.data      :
    { *(.rel.data) *(.rel.gnu.linkonce.d*) }
  .rela.data     :
    { *(.rela.data) *(.rela.gnu.linkonce.d*) }
  .rel.rodata    :
    { *(.rel.rodata) *(.rel.gnu.linkonce.r*) }
  .rela.rodata   :
    { *(.rela.rodata) *(.rela.gnu.linkonce.r*) }
  .rel.got       : { *(.rel.got)		}
  .rela.got      : { *(.rela.got)		}
  .rel.ctors     : { *(.rel.ctors)	}
  .rela.ctors    : { *(.rela.ctors)	}
  .rel.dtors     : { *(.rel.dtors)	}
  .rela.dtors    : { *(.rela.dtors)	}
  .rel.init      : { *(.rel.init)	}
  .rela.init     : { *(.rela.init)	}
  .rel.fini      : { *(.rel.fini)	}
  .rela.fini     : { *(.rela.fini)	}
  .rel.bss       : { *(.rel.bss)		}
  .rela.bss      : { *(.rela.bss)		}
  .rel.plt       : { *(.rel.plt)		}
  .rela.plt      : { *(.rela.plt)		}
  .init          : { *(.init)	} =0
  .plt      : { *(.plt)	}
  .text      :
  {
    *(.text)
    *(.stub)
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
    *(.gnu.linkonce.t*)
    *(.mips16.fn.*) *(.mips16.call.*)
  } =0
  PROVIDE (etext = .);
  .fini      : { *(.fini)    } =0
  .rodata    : { *(.rodata) *(.gnu.linkonce.r*) }
  .rodata1   : { *(.rodata1) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN(0x40000) + (. & (0x40000 - 1));
  .data    :
  {
    *(.data)
    *(.gnu.linkonce.d*)
    CONSTRUCTORS
  }
  .data1   : { *(.data1) }
  .ctors         :
  {
    *(.ctors)
  }
  .dtors         :
  {
    *(.dtors)
  }
  .got           : { *(.got.plt) *(.got) }
  .dynamic       : { *(.dynamic) }
  /* We want the small data sections together, so single-instruction offsets
     can access them all, and initialized data all before uninitialized, so
     we can shorten the on-disk segment size.  */
  .sdata     : { *(.sdata) }
  .lit8 : { *(.lit8) }
  .lit4 : { *(.lit4) }
  PROVIDE (edata = .);
  /* changeme */
  .sbss      : { 
	. = ALIGN(16);
	id_SdInt = .;			. += 4;
	common = .;			. += 4;
	id_SdEELoad = .;		. += 4;
	id_SdMain = .;			. += 4;
	id_SdSet = .;			. += 4;
	id_HSyncTim = .;		. += 4;
	sng_load_code = .;		. += 4;
	. = ALIGN(16);
	rev_off_bit = .;		. += 8;
	sound_mono_fg = .;		. += 4;
	wave_unload_size = .;		. += 4;
	wave_load_ptr = .;		. += 4;
	. = ALIGN(8);
	rev_bit_data = .;		. += 8;
	pak_read_fg = .;		. += 4;
	. = ALIGN(8);
	sng_fout_fg = .;		. += 4;
	sng_status = .;			. += 4;
	wave_load_size = .;		. += 4;
	sd_code_read = .;		. += 4;
	stop_jouchuu_se = .;		. += 4;
	. = ALIGN(16);
	keyons = .;			. += 8;
	sng_fout_term = .;		. += 8;
	sng_kaihi_fg = .;		. += 4;
	. = ALIGN(8);
	mdata4 = .;			. += 4;
	se_load_code = .;		. += 4;
	key_fg = .;			. += 4;
	se_fp = .;			. += 4;
	wave_load_code = .;		. += 4;
	spu_wave_start_ptr = .;		. += 4;
	sng_fadein_fg = .;		. += 4;
	mdata2 = .;			. += 4;
	song_end = .;			. += 8;
	fx_sound_code = .;		. += 4;
	mtrack = .;			. += 4;
	pak_fp = .;			. += 4;
	. = ALIGN(16);
	rev_on_bit = .;			. += 8;
	keyd = .;			. += 8;
	wave_save_code = .;		. += 4;
	sd_code_set = .;		. += 4;
	sng_fp = .;			. += 4;
	. = ALIGN(16);
	mdata1 = .;			. += 4;
	spu_load_offset = .;		. += 4;
	auto_env_pos = .;		. += 1;
	. = ALIGN(4);
	mptr = .;			. += 4;
	. += 4;
	sng_play_code = .;		. += 4;
	auto_env_pos2 = .;		. += 1;
	. = ALIGN(4);
	wave_load_status = .;		. += 4;
	voice_tbl = .;			. += 4;
	skip_intro_loop = .;		. += 4;
	pak_load_status = .;		. += 4;
	. = ALIGN(16);
	vox_on_vol = .;			. += 4;
	sptr = .;			. += 4;
	pak_load_code = .;		. += 4;
	sng_fadein_time = .;		. += 4;
	mdata3 = .;			. += 4;
	sng_syukan_fg = .;		. += 4;
	se_rev_on = .;			. += 4;
	fader_off_fg = .;		. += 4;
	sng_syukan_vol = .;		. += 4;
	. = ALIGN(8);
	vox_rev_on = .;			. += 4;
	sng_pause_fg = .;		. += 4;
	wave_fp = .;			. += 4;
	auto_phase_fg = .;		. += 4;
	keyoffs = .;			. += 8;
	. += 4;
	d1E0E4 = .;			. += 4;
	d1E0E8 = .;			. += 4;
	se_exp_table = .;		. += 4;
	se_header = .;			. += 4;
	se_data = .;			. += 4;
	sd_print_fg = .;		. += 4;
	se_tracks = .;			. += 4;
	. += 4;
	str_mono_offset = .;		. += 4;
	str_counter = .;		. += 4;
	str_wait_fg = .;		. += 4;
	str_wave_size = .;		. += 4;
	. = ALIGN(8);
	str_volume = .;			. += 2;
	. = ALIGN(4);
	str_counter_low = .;		. += 4;
	str_mono_fg = .;		. += 4;
	str_next_idx = .;		. += 4;
	spu_str_idx = .;		. += 4;
	str_off_ctr = .;		. += 4;
	str_status = .;			. += 4;
	spu_str_start_ptr_r = .;	. += 4;
	str_trans_offset = .;		. += 4;
	str_unplay_size = .;		. += 4;
	mute_str_l_r_fg = .;		. += 4;
	str_fp = .;			. += 4;
	str_unload_size = .;		. += 4;
	str_keyoffs = .;		. += 4;
	str_first_load = .;		. += 4;
	spu_str_start_ptr_l = .;	. += 4;
	str_play_offset = .;		. += 4;
	str_load_code = .;		. += 4;
	str_pitch = .;			. += 2;
	. = ALIGN(4);
	str_l_r_fg = .;			. += 4;
	str_play_idx = .;		. += 4;
	str_stop_fg = .;		. += 4;
	str_start_offset = .;		. += 4;
	str_trans_buf = .;		. += 4;
	str_read_idx = .;		. += 4;
	. = ALIGN(16);
	spu_str2_start_ptr_r = .;	. += 4;
	. = ALIGN(8);
	str2_iop_load_set = .;		. += 8;
	str2_wait_fg = .;		. += 8;
	str2_first_load = .;		. += 8;
	spu_str2_start_ptr_l = .;	. += 4;
	. = ALIGN(8);
	str2_off_ctr = .;		. += 4;
	. = ALIGN(16);
	str2_fp = .;			. += 4;
	. = ALIGN(8);
	str2_mono_fg = .;		. += 8;
	str2_volume = .;		. += 4;
	. = ALIGN(8);
	str2_l_r_fg = .;		. += 8;
	spu_str2_idx = .;		. += 4;
	. = ALIGN(8);
	str2_load_code = .;		. += 8;
	ee2_buf_idx = .;		. += 8;
	str2_play_offset = .;		. += 4;
	. = ALIGN(16);
	str2_stop_fg = .;		. += 8;
	str2_pitch = .;			. += 4;
	. = ALIGN(16);
	str2_unload_size = .;		. += 8;
	str2_mono_offset = .;		. += 4;
	. = ALIGN(16);
	str2_unplay_size = .;		. += 8;
	str2_next_idx = .;		. += 4;
	. = ALIGN(16);
	mute2_l_r_fg = .;		. += 4;
	. = ALIGN(8);
	str2_play_counter = .;		. += 8;
	str2_keyoffs = .;		. += 4;
	. = ALIGN(8);
	str2_mute_fg = .;		. += 8;
	str2_counter = .;		. += 8;
	str2_status = .;		. += 8;
	str2_trans_buf = .;		. += 8;
	str2_play_idx = .;		. += 4;
	. = ALIGN(16);
	str2_read_disable = .;		. += 8;
	lnr8_read_idx = .;		. += 4;
	lnr_volume = .;			. += 2;
	. = ALIGN(16);
	lnr8_play_ofst = .;		. += 4;
	lnr8_load_code = .;		. += 4;
	lnr_keyoffs = .;		. += 4;
	lnr8_first_load = .;		. += 4;
	lnr_val = .;			. += 4;
	lnr8_trans_buf = .;		. += 4;
	lnr8_play_idx = .;		. += 4;
	lnr16_next_ofst = .;		. += 4;
	lnr8_unload_size = .;		. += 4;
	lnr8_off_ctr = .;		. += 4;
	lnr8_fade_vol = .;		. += 4;
	lnr8_fp = .;			. += 4;
	lnr8_wave_size = .;		. += 4;
	lnr8_unplay_size = .;		. += 4;
	lnr8_stop_fg = .;		. += 4;
	spu_lnr16_idx = .;		. += 4;
	lnr8_read_disable = .;		. += 4;
	lnr8_counter = .;		. += 4;
	lnr8_status = .;		. += 4;
}
  /* changeme */
  .bss       :
  {
   *(.dynbss)
   *(.bss*)
	/* . = ALIGN(16);
	com_queue = .;			. += 0x230;
	pakcd_pos = .;			. += 4;
	. = ALIGN(16); */
	se_vol = .;			. += 0x30;
	se_request = .;			. += 0x90;
	mem_str_w = .;			. += 0x120;
	mem_str_buf = .;		. += 0xA0000;
	se_playing = .;			. += 0x90;
	fg_rev_set = .;			. += 0xB0;
	sd_sng_code_buf = .;		. += 0x40;
	drum_tbl = .;			. += 0x400;
	fg_syukan_off = .;		. += 0xB0;
	sound_w = .;			. += 0x2B50;
	vox_fader = .;			. += 0x20;
	spu_tr_wk = .;			. += 0xA50;
	sng_fade_value = .;		. += 0x80;
	sng_fade_time = .;		. += 0x80;
	sng_master_vol = .;		. += 0x80;
	mix_fader = .;			. += 0x200;
	path_name = .;			. += 0x80;
	se_pan = .;			. += 0x30;
	pak_header = .;			. += 0x800;
	ee_addr = .;			. += 0x30;
	wave_header = .;		. += 0x2000;
	sng_data = .;			. += 0x20000;
	se_data_area = .;		. += 0x4800;
	cdload_buf = .;			. += 0x18000;
	str_header = .;			. += 0x8800;
	str_read_status = .;		. += 0x20;
	eeload2_buf = .;		. += 0x10000;
	str2_read_status = .;		. += 0x40;
	lnr16_buf = .;			. += 0x1000;
	lnr8_read_status = .;		. += 0x80;
	lnr8_buf = .;			. += 0x8000;
	*(COMMON)
  }
  . = ALIGN(32 / 8);
  PROVIDE (end = .);
  /* Stabs debugging sections.  */
  .stab 0 : { *(.stab) }
  .stabstr 0 : { *(.stabstr) }
  .stab.excl 0 : { *(.stab.excl) }
  .stab.exclstr 0 : { *(.stab.exclstr) }
  .stab.index 0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment 0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* These must appear regardless of  .  */
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }
  /DISCARD/ : {
	*(.scommon)
	*(LOAD)
  }
}
